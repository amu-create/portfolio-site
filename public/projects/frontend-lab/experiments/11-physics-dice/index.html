<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î¨ºÎ¶¨ ÏóîÏßÑ Ï£ºÏÇ¨ÏúÑ ÎçòÏßÄÍ∏∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .throw-btn {
            padding: 12px 30px;
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            color: #000;
            border: none;
            border-radius: 30px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .throw-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .throw-btn:active {
            transform: scale(0.98);
        }

        .throw-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .dice-count-select {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            outline: none;
        }

        .dice-count-select option {
            background: #1a1a1a;
        }

        .info-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
        }

        .info-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: #00ff88;
        }

        .info-text {
            font-size: 14px;
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 10px;
        }

        .results {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .result-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .dice-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
        }

        .back-link {
            position: absolute;
            top: 30px;
            right: 30px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #00ff88;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: #00ff88;
            transform: translateY(-2px);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 20px;
            z-index: 100;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .camera-controls {
            position: absolute;
            top: 120px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            color: #aaa;
        }

        .control-hint {
            margin-bottom: 8px;
        }

        .total-sum {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 20px;
            color: #00ff88;
            font-weight: bold;
        }

        .error-message {
            color: #ff4444;
            font-size: 16px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div class="loader"></div>
        <p>Î¨ºÎ¶¨ ÏóîÏßÑ Î°úÎî© Ï§ë...</p>
    </div>

    <div class="info-panel">
        <h2 class="info-title">Î¨ºÎ¶¨ ÏóîÏßÑ Ï£ºÏÇ¨ÏúÑ</h2>
        <p class="info-text">
            Three.jsÏôÄ Cannon.jsÎ•º ÌôúÏö©Ìïú Ïã§Ï†ú Î¨ºÎ¶¨ Î≤ïÏπôÏù¥ Ï†ÅÏö©ÎêòÎäî 3D Ï£ºÏÇ¨ÏúÑ ÏãúÎÆ¨Î†àÏù¥ÏÖò
        </p>
        <div class="results" id="results" style="display: none;">
            <h3 style="margin-bottom: 10px; color: #00d4ff;">Ï£ºÏÇ¨ÏúÑ Í≤∞Í≥º</h3>
            <div id="result-list"></div>
            <div class="total-sum" id="total-sum"></div>
        </div>
    </div>

    <div class="camera-controls">
        <div class="control-hint">üñ±Ô∏è ÎßàÏö∞Ïä§: Ïπ¥Î©îÎùº ÌöåÏ†Ñ</div>
        <div class="control-hint">üîÑ Ìú†: ÌôïÎåÄ/Ï∂ïÏÜå</div>
        <div class="control-hint">üé≤ Ïó¨Îü¨ Í∞ú ÎèôÏãú ÎçòÏßÄÍ∏∞ Í∞ÄÎä•</div>
    </div>

    <div class="controls">
        <select class="dice-count-select" id="dice-count">
            <option value="1" selected>Ï£ºÏÇ¨ÏúÑ 1Í∞ú</option>
            <option value="2">Ï£ºÏÇ¨ÏúÑ 2Í∞ú</option>
            <option value="3">Ï£ºÏÇ¨ÏúÑ 3Í∞ú</option>
            <option value="5">Ï£ºÏÇ¨ÏúÑ 5Í∞ú</option>
            <option value="10">Ï£ºÏÇ¨ÏúÑ 10Í∞ú</option>
            <option value="20">Ï£ºÏÇ¨ÏúÑ 20Í∞ú</option>
        </select>
        <select class="dice-count-select" id="dice-type">
            <option value="standard" selected>ÌëúÏ§Ä Ï£ºÏÇ¨ÏúÑ</option>
            <option value="custom">Ïª§Ïä§ÌÖÄ Ï£ºÏÇ¨ÏúÑ</option>
        </select>
        <button class="throw-btn" id="throw-btn">Ï£ºÏÇ¨ÏúÑ ÎçòÏßÄÍ∏∞</button>
        <a href="../09-3d-cube/index.html" class="button button-secondary" style="text-decoration: none; display: inline-block; padding: 12px 20px; background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 30px; font-weight: bold; font-size: 16px;">Ï£ºÏÇ¨ÏúÑ ÎßåÎì§Í∏∞</a>
    </div>

    <a href="/projects/frontend-lab/" class="back-link">‚Üê Ïã§ÌóòÏã§Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞</a>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
            integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==" 
            crossorigin="anonymous"></script>
    
    <!-- Cannon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"
            integrity="sha512-jH8qS2SqsLhI8EJAX19jJMYDMrjn2l5VBJTgdFKLJBwfpoFtTYvd9dujoFMOjYiAKdHLV6xOzYKy6hHC5bvAjQ=="
            crossorigin="anonymous"></script>
    
    <!-- OrbitControlsÎäî Ïù∏ÎùºÏù∏ÏúºÎ°ú Ìè¨Ìï® -->
    <script>
    // Three.js OrbitControls Ïù∏ÎùºÏù∏ Ï†ïÏùò
    THREE.OrbitControls = function ( object, domElement ) {
        this.object = object;
        this.domElement = ( domElement !== undefined ) ? domElement : document;
        this.enabled = true;
        this.target = new THREE.Vector3();
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.minZoom = 0;
        this.maxZoom = Infinity;
        this.minPolarAngle = 0;
        this.maxPolarAngle = Math.PI;
        this.minAzimuthAngle = - Infinity;
        this.maxAzimuthAngle = Infinity;
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.enableZoom = true;
        this.zoomSpeed = 1.0;
        this.enableRotate = true;
        this.rotateSpeed = 1.0;
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = false;
        this.keyPanSpeed = 7.0;
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0;
        this.enableKeys = true;
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
        this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;
        this.getPolarAngle = function () {
            return spherical.phi;
        };
        this.getAzimuthalAngle = function () {
            return spherical.theta;
        };
        this.saveState = function () {
            scope.target0.copy( scope.target );
            scope.position0.copy( scope.object.position );
            scope.zoom0 = scope.object.zoom;
        };
        this.reset = function () {
            scope.target.copy( scope.target0 );
            scope.object.position.copy( scope.position0 );
            scope.object.zoom = scope.zoom0;
            scope.object.updateProjectionMatrix();
            scope.dispatchEvent( changeEvent );
            scope.update();
            state = STATE.NONE;
        };
        this.update = function () {
            var offset = new THREE.Vector3();
            var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
            var quatInverse = quat.clone().invert();
            var lastPosition = new THREE.Vector3();
            var lastQuaternion = new THREE.Quaternion();
            return function update() {
                var position = scope.object.position;
                offset.copy( position ).sub( scope.target );
                offset.applyQuaternion( quat );
                spherical.setFromVector3( offset );
                if ( scope.autoRotate && state === STATE.NONE ) {
                    rotateLeft( getAutoRotationAngle() );
                }
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
                spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );
                spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
                spherical.makeSafe();
                spherical.radius *= scale;
                spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );
                scope.target.add( panOffset );
                offset.setFromSpherical( spherical );
                offset.applyQuaternion( quatInverse );
                position.copy( scope.target ).add( offset );
                scope.object.lookAt( scope.target );
                if ( scope.enableDamping === true ) {
                    sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                    sphericalDelta.phi *= ( 1 - scope.dampingFactor );
                    panOffset.multiplyScalar( 1 - scope.dampingFactor );
                } else {
                    sphericalDelta.set( 0, 0, 0 );
                    panOffset.set( 0, 0, 0 );
                }
                scale = 1;
                if ( zoomChanged ||
                    lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                    8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {
                    scope.dispatchEvent( changeEvent );
                    lastPosition.copy( scope.object.position );
                    lastQuaternion.copy( scope.object.quaternion );
                    zoomChanged = false;
                    return true;
                }
                return false;
            };
        }();
        this.dispose = function () {
            scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
            scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
            scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );
            scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
            scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
            scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );
            document.removeEventListener( 'mousemove', onMouseMove, false );
            document.removeEventListener( 'mouseup', onMouseUp, false );
            window.removeEventListener( 'keydown', onKeyDown, false );
        };
        var scope = this;
        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start' };
        var endEvent = { type: 'end' };
        var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };
        var state = STATE.NONE;
        var EPS = 0.000001;
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();
        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;
        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();
        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();
        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();
        function getAutoRotationAngle() {
            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }
        function getZoomScale() {
            return Math.pow( 0.95, scope.zoomSpeed );
        }
        function rotateLeft( angle ) {
            sphericalDelta.theta -= angle;
        }
        function rotateUp( angle ) {
            sphericalDelta.phi -= angle;
        }
        var panLeft = function () {
            var v = new THREE.Vector3();
            return function panLeft( distance, objectMatrix ) {
                v.setFromMatrixColumn( objectMatrix, 0 );
                v.multiplyScalar( - distance );
                panOffset.add( v );
            };
        }();
        var panUp = function () {
            var v = new THREE.Vector3();
            return function panUp( distance, objectMatrix ) {
                if ( scope.screenSpacePanning === true ) {
                    v.setFromMatrixColumn( objectMatrix, 1 );
                } else {
                    v.setFromMatrixColumn( objectMatrix, 0 );
                    v.crossVectors( scope.object.up, v );
                }
                v.multiplyScalar( distance );
                panOffset.add( v );
            };
        }();
        var pan = function () {
            var offset = new THREE.Vector3();
            return function pan( deltaX, deltaY ) {
                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                if ( scope.object.isPerspectiveCamera ) {
                    var position = scope.object.position;
                    offset.copy( position ).sub( scope.target );
                    var targetDistance = offset.length();
                    targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );
                    panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                    panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );
                } else if ( scope.object.isOrthographicCamera ) {
                    panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                    panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                    scope.enablePan = false;
                }
            };
        }();
        function dollyIn( dollyScale ) {
            if ( scope.object.isPerspectiveCamera ) {
                scale /= dollyScale;
            } else if ( scope.object.isOrthographicCamera ) {
                scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            } else {
                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                scope.enableZoom = false;
            }
        }
        function dollyOut( dollyScale ) {
            if ( scope.object.isPerspectiveCamera ) {
                scale *= dollyScale;
            } else if ( scope.object.isOrthographicCamera ) {
                scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            } else {
                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                scope.enableZoom = false;
            }
        }
        function handleMouseDownRotate( event ) {
            rotateStart.set( event.clientX, event.clientY );
        }
        function handleMouseDownDolly( event ) {
            dollyStart.set( event.clientX, event.clientY );
        }
        function handleMouseDownPan( event ) {
            panStart.set( event.clientX, event.clientY );
        }
        function handleMouseMoveRotate( event ) {
            rotateEnd.set( event.clientX, event.clientY );
            rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
            rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight );
            rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
            rotateStart.copy( rotateEnd );
            scope.update();
        }
        function handleMouseMoveDolly( event ) {
            dollyEnd.set( event.clientX, event.clientY );
            dollyDelta.subVectors( dollyEnd, dollyStart );
            if ( dollyDelta.y > 0 ) {
                dollyIn( getZoomScale() );
            } else if ( dollyDelta.y < 0 ) {
                dollyOut( getZoomScale() );
            }
            dollyStart.copy( dollyEnd );
            scope.update();
        }
        function handleMouseMovePan( event ) {
            panEnd.set( event.clientX, event.clientY );
            panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
            pan( panDelta.x, panDelta.y );
            panStart.copy( panEnd );
            scope.update();
        }
        function handleMouseWheel( event ) {
            if ( event.deltaY < 0 ) {
                dollyOut( getZoomScale() );
            } else if ( event.deltaY > 0 ) {
                dollyIn( getZoomScale() );
            }
            scope.update();
        }
        function handleKeyDown( event ) {
            switch ( event.keyCode ) {
                case scope.keys.UP:
                    pan( 0, scope.keyPanSpeed );
                    scope.update();
                    break;
                case scope.keys.BOTTOM:
                    pan( 0, - scope.keyPanSpeed );
                    scope.update();
                    break;
                case scope.keys.LEFT:
                    pan( scope.keyPanSpeed, 0 );
                    scope.update();
                    break;
                case scope.keys.RIGHT:
                    pan( - scope.keyPanSpeed, 0 );
                    scope.update();
                    break;
            }
        }
        function handleTouchStartRotate( event ) {
            rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
        }
        function handleTouchStartDollyPan( event ) {
            if ( scope.enableZoom ) {
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                var distance = Math.sqrt( dx * dx + dy * dy );
                dollyStart.set( 0, distance );
            }
            if ( scope.enablePan ) {
                var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );
                panStart.set( x, y );
            }
        }
        function handleTouchMoveRotate( event ) {
            rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
            rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
            rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight );
            rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
            rotateStart.copy( rotateEnd );
            scope.update();
        }
        function handleTouchMoveDollyPan( event ) {
            if ( scope.enableZoom ) {
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                var distance = Math.sqrt( dx * dx + dy * dy );
                dollyEnd.set( 0, distance );
                dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );
                dollyIn( dollyDelta.y );
                dollyStart.copy( dollyEnd );
            }
            if ( scope.enablePan ) {
                var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );
                panEnd.set( x, y );
                panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
                pan( panDelta.x, panDelta.y );
                panStart.copy( panEnd );
            }
            scope.update();
        }
        function onMouseDown( event ) {
            if ( scope.enabled === false ) return;
            event.preventDefault();
            switch ( event.button ) {
                case scope.mouseButtons.LEFT:
                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {
                        if ( scope.enablePan === false ) return;
                        handleMouseDownPan( event );
                        state = STATE.PAN;
                    } else {
                        if ( scope.enableRotate === false ) return;
                        handleMouseDownRotate( event );
                        state = STATE.ROTATE;
                    }
                    break;
                case scope.mouseButtons.MIDDLE:
                    if ( scope.enableZoom === false ) return;
                    handleMouseDownDolly( event );
                    state = STATE.DOLLY;
                    break;
                case scope.mouseButtons.RIGHT:
                    if ( scope.enablePan === false ) return;
                    handleMouseDownPan( event );
                    state = STATE.PAN;
                    break;
            }
            if ( state !== STATE.NONE ) {
                document.addEventListener( 'mousemove', onMouseMove, false );
                document.addEventListener( 'mouseup', onMouseUp, false );
                scope.dispatchEvent( startEvent );
            }
        }
        function onMouseMove( event ) {
            if ( scope.enabled === false ) return;
            event.preventDefault();
            switch ( state ) {
                case STATE.ROTATE:
                    if ( scope.enableRotate === false ) return;
                    handleMouseMoveRotate( event );
                    break;
                case STATE.DOLLY:
                    if ( scope.enableZoom === false ) return;
                    handleMouseMoveDolly( event );
                    break;
                case STATE.PAN:
                    if ( scope.enablePan === false ) return;
                    handleMouseMovePan( event );
                    break;
            }
        }
        function onMouseUp( event ) {
            if ( scope.enabled === false ) return;
            document.removeEventListener( 'mousemove', onMouseMove, false );
            document.removeEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( endEvent );
            state = STATE.NONE;
        }
        function onMouseWheel( event ) {
            if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;
            event.preventDefault();
            event.stopPropagation();
            scope.dispatchEvent( startEvent );
            handleMouseWheel( event );
            scope.dispatchEvent( endEvent );
        }
        function onKeyDown( event ) {
            if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;
            handleKeyDown( event );
        }
        function onTouchStart( event ) {
            if ( scope.enabled === false ) return;
            event.preventDefault();
            switch ( event.touches.length ) {
                case 1:
                    if ( scope.enableRotate === false ) return;
                    handleTouchStartRotate( event );
                    state = STATE.TOUCH_ROTATE;
                    break;
                case 2:
                    if ( scope.enableZoom === false && scope.enablePan === false ) return;
                    handleTouchStartDollyPan( event );
                    state = STATE.TOUCH_DOLLY_PAN;
                    break;
                default:
                    state = STATE.NONE;
            }
            if ( state !== STATE.NONE ) {
                scope.dispatchEvent( startEvent );
            }
        }
        function onTouchMove( event ) {
            if ( scope.enabled === false ) return;
            event.preventDefault();
            event.stopPropagation();
            switch ( event.touches.length ) {
                case 1:
                    if ( scope.enableRotate === false ) return;
                    if ( state !== STATE.TOUCH_ROTATE ) return;
                    handleTouchMoveRotate( event );
                    break;
                case 2:
                    if ( scope.enableZoom === false && scope.enablePan === false ) return;
                    if ( state !== STATE.TOUCH_DOLLY_PAN ) return;
                    handleTouchMoveDollyPan( event );
                    break;
                default:
                    state = STATE.NONE;
            }
        }
        function onTouchEnd( event ) {
            if ( scope.enabled === false ) return;
            scope.dispatchEvent( endEvent );
            state = STATE.NONE;
        }
        function onContextMenu( event ) {
            if ( scope.enabled === false ) return;
            event.preventDefault();
        }
        scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );
        scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
        scope.domElement.addEventListener( 'wheel', onMouseWheel, false );
        scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
        scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
        scope.domElement.addEventListener( 'touchmove', onTouchMove, false );
        window.addEventListener( 'keydown', onKeyDown, false );
        this.update();
    };
    THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
    </script>
    
    <script src="dice.js"></script>
</body>
</html>